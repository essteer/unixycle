#!/bin/bash

################################
# Unixycle - A UNIX recycle bin
################################
# Date: 16/08/2024
# Author: Elliott Steer
# `recycle` creates a recyclebin directory in a user's $HOME and 
# stores target files there with their inode numbers appended. It
# can recursively recycle directory contents via the -r option.
# 
# File usage:
# "$ bash recycle -iv file1.txt file2.doc moreFiles*"
# 
# Directory usage:
# "$ bash recycle -irv dir1"
#
# Data for recycled files is stored in $HOME/.restore.info.
# See the accompanying `restore` script for details.
################################

recycle_script_abs_path=$(realpath $0)
recyclebin_abs_path="$HOME/recyclebin"
restore_info_abs_path="$HOME/.restore.info"
mkdir -p "$recyclebin_abs_path"  # create recyclebin if it does not exist
if ! [ -e "$restore_info_abs_path" ] ; then
    touch "$restore_info_abs_path"  # create .restore.info if it does not exist
fi

if [ $# -eq 0 ] ; then
    echo "recycle: missing operand"
    exit 1  # exit if no args provided
fi


function validate_file() {
    # validates: file exists, file is file, file is not recycle
    if ! [ -e "$1" ] ; then
        echo "cannot recycle '$1': no such file"
        return 3  # exit function if file does not exist
    elif [ -d "$1" ] && [ "$recursive" != true ] ; then
        echo "cannot recycle '$1': use -r to recycle directories"
        return 4  # exit function if dir provided
    fi
    target_abs_path=$(realpath $1)
    if [ "$target_abs_path" = "$recycle_script_abs_path" ] ; then
        echo "attempting to delete recycle - operation aborted"
        exit 5  # exit script if recycle script provided
    fi
    return 0  # is valid file
}


function recycle_file() {
    # recycles a previously validated file
    target_abs_path=$(realpath $1)
    target_filename=$(basename "$1")
    target_inode=$(ls -i $target_abs_path | cut -d" " -f1)
    recycle_state_name="${target_filename}_${target_inode}"
    recycle_state_abs_path="${recyclebin_abs_path}/${recycle_state_name}"
    name_in_restore_info="${recycle_state_name}:${target_abs_path}"

    # move target file to recyclebin under recycle_state_name
    mv "$target_abs_path" "$recycle_state_abs_path"
    # store name in .restore.info
    echo "$name_in_restore_info" >> "$restore_info_abs_path"
}


function recycle_dir() {
    # recycles all files in a directory via recursion
    for j in "$1"/* ; do
        # validate to prevent deletion of recycle script in sub dir
        if validate_file "$j" ; then
            if [ -f "$j" ] ; then
                recycle_file "$j"
                if [ "$verbose" = true ] ; then
                    echo "recycled '$j'"
                fi
            elif [ -d "$j" ] ; then
                recycle_dir "$j"  # recursion
            fi
        fi
    done
    rm -rf "$1"  # delete dir once all contents recycled
    return 0
}


OPTIND=1
while getopts ":irv" opt
do
    case $opt in
        i|I) interactive=true ;;
        r|R) recursive=true ;;
        v|V) verbose=true ;;
        \?) echo "invalid option: $OPTARG"
            exit 2 ;;
    esac
done
shift $((OPTIND-1))


for i in "$@"
do
    if validate_file "$i" ; then  # validate each file before attempting to recycle

        if [ "$interactive" = true ] ; then
            read -p "recycle '$i'? y/n " recycleDecision
            if [ "$recycleDecision" != "y" ] && [ "$recycleDecision" != "Y" ] ; then
                continue ;  # continue iteration if user doesn't affirm deletion
            fi
        fi

        if [ -d "$i" ] && [ "$recursive" = true ] ; then
            recycle_dir "$i"  # recycle dir contents (-r)
        else
            recycle_file "$i"  # recycle file
        fi

        if [ "$verbose" = true ] ; then
            echo "recycled '$i'"
        fi
    fi
done

exit 0
